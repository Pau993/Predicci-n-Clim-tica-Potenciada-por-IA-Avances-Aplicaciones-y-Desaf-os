# -*- coding: utf-8 -*-
"""Proyecto Arep

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1afo8qccbWFVhN_o8gaZUrtfNDk-T680U

# **Cambio Climático**

https://datosabiertos.bogota.gov.co/dataset/cambio-climatico
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd

df = pd.read_csv('osb_saludamb_consolidadocambioclimatico.csv', encoding='latin1', sep=';')
df.head()

from sklearn.cluster import KMeans
import numpy as np

# Preprocesamiento de columnas numéricas (reemplazar comas por puntos y convertir a float)
columnas_convertir = ['Temperatura Máxima', 'Temperatura mínima']
for col in columnas_convertir:
    df[col] = df[col].astype(str).str.replace(',', '.').astype(float)

# Selección de variables para clustering
variables_cluster = df[columnas_convertir].dropna()

# Aplicar K-means con 5 clústeres (una por región geográfica de Colombia)
kmeans = KMeans(n_clusters=5, random_state=0, n_init='auto').fit(variables_cluster)

# Añadir etiquetas de región al DataFrame original (donde no haya valores nulos)
df.loc[variables_cluster.index, 'Region_Climatica'] = kmeans.labels_

# Mostrar algunos resultados
df[['Año', 'Mes', 'Temperatura Máxima', 'Temperatura mínima', 'Region_Climatica']].dropna().head()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# 4. Análisis gráfico: Distribución de temperatura máxima y mínima
plt.figure(figsize=(12,5))

plt.subplot(1,2,1)
sns.histplot(df['Temperatura Máxima'].dropna(), bins=30, kde=True, color='orange')
plt.title('Distribución de Temperatura Máxima')

plt.subplot(1,2,2)
sns.histplot(df['Temperatura mínima'].dropna(), bins=30, kde=True, color='blue')
plt.title('Distribución de Temperatura Mínima')

plt.show()

# 5. Relación entre temperatura máxima y dengue (filtrando datos completos)
if 'Dengue' in df.columns:
    df['Dengue'] = pd.to_numeric(df['Dengue'], errors='coerce')
    df_clean = df.dropna(subset=['Temperatura Máxima', 'Dengue'])

    plt.figure(figsize=(6,4))
    sns.scatterplot(data=df_clean, x='Temperatura Máxima', y='Dengue')
    plt.title('Relación Temperatura Máxima vs Casos de Dengue')
    plt.show()

# 6. Matriz de correlación (numéricas)
numeric_cols = df.select_dtypes(include='number').columns
plt.figure(figsize=(10,8))
sns.heatmap(df[numeric_cols].corr(), annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Matriz de Correlación')
plt.show()

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import LabelEncoder

# Supongamos que ya limpiaste y convertiste las columnas numéricas

# Variables objetivo
target_temp = "Temperatura Máxima"
target_lluvia = "Lluvia Acumulada"

# Variables predictoras ejemplo
features = ['Año', 'No. Mes', 'Temperatura mínima']

# Codificar variable categórica si existe
if 'ENOS' in df.columns:
    le = LabelEncoder()
    df['ENOS_enc'] = le.fit_transform(df['ENOS'].fillna('Unknown'))
    features.append('ENOS_enc')

# Modelo para Temperatura Máxima
df_temp = df[features + [target_temp]].dropna()
X_temp = df_temp[features]
y_temp = df_temp[target_temp]

X_train_temp, X_test_temp, y_train_temp, y_test_temp = train_test_split(
    X_temp, y_temp, test_size=0.2, random_state=42)

model_temp = RandomForestRegressor(n_estimators=100, random_state=42)
model_temp.fit(X_train_temp, y_train_temp)
y_pred_temp = model_temp.predict(X_test_temp)

mse_temp = mean_squared_error(y_test_temp, y_pred_temp)
rmse_temp = np.sqrt(mse_temp)
print(f"RMSE Temperatura Máxima: {rmse_temp:.2f}")

# Reemplazar coma por punto y convertir a float
df['Lluvia Acumulada'] = df['Lluvia Acumulada'].astype(str).str.replace(',', '.')
df['Lluvia Acumulada'] = pd.to_numeric(df['Lluvia Acumulada'], errors='coerce')


# Modelo para Lluvia Acumulada
df_lluvia = df[features + [target_lluvia]].dropna()
X_lluvia = df_lluvia[features]
y_lluvia = df_lluvia[target_lluvia]

X_train_lluvia, X_test_lluvia, y_train_lluvia, y_test_lluvia = train_test_split(
    X_lluvia, y_lluvia, test_size=0.2, random_state=42)


model_lluvia = RandomForestRegressor(n_estimators=100, random_state=42)
model_lluvia.fit(X_train_lluvia, y_train_lluvia)
y_pred_lluvia = model_lluvia.predict(X_test_lluvia)

mse_lluvia = mean_squared_error(y_test_lluvia, y_pred_lluvia)
rmse_lluvia = np.sqrt(mse_lluvia)
print(f"RMSE Lluvia Acumulada: {rmse_lluvia:.2f}")

# Ejemplo de nuevo registro (debes adaptar con variables reales)
nuevo_dato = {
    'Año': 2025,
    'No. Mes': 5,
    'Temperatura mínima': 15.5,
    'ENOS_enc': 1  # si usas esta variable, debes codificarla igual que antes
}

import pandas as pd

# Convertir a DataFrame
df_nuevo = pd.DataFrame([nuevo_dato])

# Predicción
temp_pred = model_temp.predict(df_nuevo)[0]
lluvia_pred = model_lluvia.predict(df_nuevo)[0]

print(f"Predicción Temperatura Máxima: {temp_pred:.2f}")
print(f"Predicción Lluvia Acumulada: {lluvia_pred:.2f}")

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.optimizers import Adam

# 1. Limpieza (adaptar a tu df)
df['Temperatura Máxima'] = df['Temperatura Máxima'].astype(str).str.replace(',', '.')
df['Temperatura Máxima'] = pd.to_numeric(df['Temperatura Máxima'], errors='coerce')

df['Temperatura mínima'] = df['Temperatura mínima'].astype(str).str.replace(',', '.')
df['Temperatura mínima'] = pd.to_numeric(df['Temperatura mínima'], errors='coerce')

# Codificar variable categórica si tienes
if 'ENOS' in df.columns:
    le = LabelEncoder()
    df['ENOS_enc'] = le.fit_transform(df['ENOS'].fillna('Unknown'))

# Variables predictoras y objetivo
features = ['Año', 'No. Mes', 'Temperatura mínima']
if 'ENOS_enc' in df.columns:
    features.append('ENOS_enc')

target = 'Temperatura Máxima'

df_nn = df[features + [target]].dropna()

X = df_nn[features].values
y = df_nn[target].values

# 2. Escalar características (normalización)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# 3. Separar datos train/test
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# 4. Definir modelo secuencial simple
model = Sequential([
    Dense(64, activation='relu', input_shape=(X_train.shape[1],)),
    Dense(32, activation='relu'),
    Dense(1)  # salida para regresión
])

model.compile(optimizer=Adam(learning_rate=0.001), loss='mse', metrics=['mae'])

# 5. Entrenar modelo
history = model.fit(X_train, y_train, validation_split=0.2, epochs=50, batch_size=32)

# 6. Evaluar modelo
loss, mae = model.evaluate(X_test, y_test)
print(f"Test MAE: {mae:.2f}")

# 7. Hacer predicciones ejemplo
y_pred = model.predict(X_test)

import matplotlib.pyplot as plt

plt.scatter(y_test, y_pred)
plt.xlabel("Temperatura Máxima real")
plt.ylabel("Predicción Temperatura Máxima")
plt.title("Predicción vs Real con Red Neuronal")
plt.show()

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, StandardScaler
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Dense
from tensorflow.keras.optimizers import Adam

# --- Limpieza y preparación ---
df['Temperatura Máxima'] = df['Temperatura Máxima'].astype(str).str.replace(',', '.')
df['Temperatura Máxima'] = pd.to_numeric(df['Temperatura Máxima'], errors='coerce')

df['Lluvia Acumulada'] = df['Lluvia Acumulada'].astype(str).str.replace(',', '.')
df['Lluvia Acumulada'] = pd.to_numeric(df['Lluvia Acumulada'], errors='coerce')

df['Temperatura mínima'] = df['Temperatura mínima'].astype(str).str.replace(',', '.')
df['Temperatura mínima'] = pd.to_numeric(df['Temperatura mínima'], errors='coerce')

# Codificar variable categórica si tienes
if 'ENOS' in df.columns:
    le = LabelEncoder()
    df['ENOS_enc'] = le.fit_transform(df['ENOS'].fillna('Unknown'))

features = ['Año', 'No. Mes', 'Temperatura mínima']
if 'ENOS_enc' in df.columns:
    features.append('ENOS_enc')

target_temp = 'Temperatura Máxima'
target_lluvia = 'Lluvia Acumulada'

# Eliminar filas con NA en cualquiera de las columnas usadas
df_model = df[features + [target_temp, target_lluvia]].dropna()

X = df_model[features].values
y_temp = df_model[target_temp].values
y_lluvia = df_model[target_lluvia].values

# Escalar features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# División de datos
X_train, X_test, y_train_temp, y_test_temp, y_train_lluvia, y_test_lluvia = train_test_split(
    X_scaled, y_temp, y_lluvia, test_size=0.2, random_state=42)

# --- Modelo multitarea ---
input_layer = Input(shape=(X_train.shape[1],))

# Capas compartidas
shared = Dense(64, activation='relu')(input_layer)
shared = Dense(32, activation='relu')(shared)

# Salida para Temperatura Máxima
output_temp = Dense(1, name='temp_output')(shared)

# Salida para Lluvia Acumulada
output_lluvia = Dense(1, name='lluvia_output')(shared)

# Definir modelo
model = Model(inputs=input_layer, outputs=[output_temp, output_lluvia])

# Compilar modelo con pérdidas por separado (ambas MSE)
model.compile(optimizer=Adam(0.001),
              loss={'temp_output': 'mse', 'lluvia_output': 'mse'},
              metrics={'temp_output': 'mae', 'lluvia_output': 'mae'})

# Entrenar modelo
history = model.fit(
    X_train,
    {'temp_output': y_train_temp, 'lluvia_output': y_train_lluvia},
    validation_split=0.2,
    epochs=50,
    batch_size=32
)

# Evaluar
losses = model.evaluate(X_test, {'temp_output': y_test_temp, 'lluvia_output': y_test_lluvia})
print(f"Pérdida total: {losses[0]:.4f}")
print(f"Pérdida Temperatura Máxima: {losses[1]:.4f}, MAE: {losses[3]:.4f}")
print(f"Pérdida Lluvia Acumulada: {losses[2]:.4f}, MAE: {losses[4]:.4f}")

# Predicciones
preds = model.predict(X_test)
pred_temp = preds[0].flatten()
pred_lluvia = preds[1].flatten()

# Graficar resultados Temperatura Máxima
import matplotlib.pyplot as plt

plt.scatter(y_test_temp, pred_temp)
plt.xlabel('Temperatura Máxima Real')
plt.ylabel('Predicción Temperatura Máxima')
plt.title('Predicción Temperatura Máxima - Modelo Multitarea')
plt.show()

# Graficar resultados Lluvia Acumulada
plt.scatter(y_test_lluvia, pred_lluvia)
plt.xlabel('Lluvia Acumulada Real')
plt.ylabel('Predicción Lluvia Acumulada')
plt.title('Predicción Lluvia Acumulada - Modelo Multitarea')
plt.show()